#include "ft_ssl_md5.h"static void _sha256_start(t_sha256 *data){    data->h0 = data->init.h0;    data->h1 = data->init.h1;    data->h2 = data->init.h2;    data->h3 = data->init.h3;    data->h4 = data->init.h4;    data->h5 = data->init.h5;    data->h6 = data->init.h6;    data->h7 = data->init.h7;}static void _sha256_end(t_sha256 *data){    data->init.h0 += data->h0;    data->init.h1 += data->h1;    data->init.h2 += data->h2;    data->init.h3 += data->h3;    data->init.h4 += data->h4;    data->init.h5 += data->h5;    data->init.h6 += data->h6;    data->init.h7 += data->h7;}static void word_generator(uint32_t *storage, uint8_t *block){    size_t i;    uint32_t s0;    uint32_t s1;    i = 0;    while (i < 16)    {        storage[i] = uint32_to_b_endian(*(uint32_t *)&block[i * 4]);        i++;    }    while (i < 64)    {        s0 = ROR(storage[i - 15], 7) ^ \             ROR(storage[i - 15], 18) ^ (storage[i - 15] >> 3);        s1 = ROR(storage[i - 2], 17) ^ \             ROR(storage[i - 2], 19) ^ (storage[i - 2] >> 10);        storage[i] = storage[i - 16] + s0 + storage[i - 7] + s1;        i++;    }}static void _sha256(uint8_t *block, t_sha256 *data){    uint32_t storage[64];    uint32_t t1;    uint32_t t2;    int      i;    i = 0;    word_generator(storage, block);    _sha256_start(data);    while (i < 64)    {        t2 = FUNC_E0(data->h0) + FUNC_MA(data->h0, data->h1, data->h2);        t1 = data->h7 + FUNC_E1(data->h4) +\             FUNC_CH(data->h4, data->h5, data->h6) +\             T_SHA[i] + storage[i];        data->h7 = data->h6;        data->h6 = data->h5;        data->h5 = data->h4;        data->h4 = data->h3 + t1;        data->h3 = data->h2;        data->h2 = data->h1;        data->h1 = data->h0;        data->h0 = t1 + t2;        i++;    }    _sha256_end(data);}int    sha256(t_cntrl *c_block){    t_sha256        dt;    sha256_init(&dt);    while (1)    {        if (msg_reader(c_block, &dt.t_len, dt.buf, &dt.read_n))            break;        if (!(dt.chnk = r_chnk(dt.buf, dt.read_n, \             uint64_to_b_endian(dt.t_len), &dt.chnk_qnt)))            return (0x01);        _sha256(dt.chnk, &dt);        if (dt.chnk_qnt == 0x02)            _sha256(&dt.chnk[0x40], &dt);        if (!dt.chnk)        {            free(dt.chnk);            dt.chnk = NULL;        }    }    print_hash_sha256(&dt);    return (0);}